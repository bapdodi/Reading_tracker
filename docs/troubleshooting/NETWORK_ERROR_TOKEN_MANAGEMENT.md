# 네트워크 에러 시 토큰 관리 개선

> **문제**: 서버 재시작 시 토큰 무효화와 오프라인 메모 동기화 시나리오를 고려한 인증 로직 개선  
> **날짜**: 2024년  
> **관련 문서**: [오프라인 메모 동기화 설계](../fault-tolerance/OFFLINE_MEMO_SYNC.md)

---

## 📋 목차

1. [문제 정의](#문제-정의)
2. [원인 진단](#원인-진단)
3. [인증 에러(401) vs 네트워크 에러 비교](#인증-에러401-vs-네트워크-에러-비교)
4. [해결책 비교](#해결책-비교)
5. [개선 방안](#개선-방안)
6. [구현 계획](#구현-계획)

---

## 문제 정의

### 문제 상황

1. **서버 재시작 시 토큰 무효화 요구사항**
   - 서버 재시작 시 모든 사용자 세션을 강제 종료해야 함
   - 보안상 서버 재시작 후 기존 토큰은 무효화되어야 함

2. **오프라인 메모 동기화 시나리오**
   - 사용자가 오프라인 상태에서 메모 작성 (로컬 저장)
   - 네트워크 복구 시 자동 동기화 시도
   - 서버가 종료되어 있으면 네트워크 에러 발생
   - 현재 로직: 네트워크 에러 시 자동 로그아웃 → 토큰 삭제
   - **문제**: 서버 재시작 후에도 토큰이 없어서 오프라인 메모 동기화 불가능

### 시나리오 예시

```
[시나리오 1: 서버 종료 중 네트워크 복구]
1. 사용자가 오프라인 상태에서 메모 작성 (IndexedDB에 저장)
2. 네트워크 복구 → 자동 동기화 시도
3. 서버가 종료되어 있음 → 네트워크 에러 발생
4. 현재 로직: 자동 로그아웃 → 토큰 삭제 ❌
5. 문제: 서버 재시작 후에도 토큰이 없어서 동기화 불가능

[시나리오 2: 서버 재시작 (토큰 무효화)]
1. 사용자가 오프라인 상태에서 메모 작성 (로컬 저장)
2. 서버 재시작 (방안 1: 토큰 무효화)
3. 네트워크 복구 → 자동 동기화 시도
4. 401 에러 발생 (토큰 무효화)
5. 토큰 갱신 시도 → RefreshToken도 무효화 → 실패
6. 로그아웃 처리 ✅ (정상 동작)
```

---

## 원인 진단

### 현재 로직 분석

**파일**: `분산2_프로젝트_프론트/js/state/auth-state.js`

```javascript
async restoreAuthState() {
  try {
    const userProfile = await userService.getProfile();
    if (userProfile) {
      this.setUser(userProfile);
    } else {
      this.logout();
    }
  } catch (error) {
    // 네트워크 에러인지 확인
    const isNetworkError = 
      error.isNetworkError === true ||
      error.message?.includes('Failed to fetch') ||
      // ... 기타 네트워크 에러 조건
    
    if (isNetworkError) {
      // ❌ 문제: 네트워크 에러 시 토큰 삭제
      this.logout({ reason: 'network_error' });
    } else {
      if (error.status === 401 || error.statusCode === 401) {
        this.logout({ reason: 'token_invalid' });
      } else {
        // 기타 에러는 인증 상태만 초기화 (토큰은 유지)
        this.isAuthenticated = false;
        this.user = null;
      }
    }
  }
}
```

### 문제점

1. **네트워크 에러와 인증 에러(401)를 구분하지 않음**
   - 네트워크 에러는 일시적 (서버 종료, 네트워크 끊김 등)
   - 인증 에러는 영구적 (토큰 만료, 무효화 등)
   - 현재 로직은 둘 다 동일하게 처리 (토큰 삭제)

2. **오프라인 메모 동기화와 충돌**
   - 오프라인 메모 동기화 시나리오에서 서버가 종료되어 있으면 네트워크 에러 발생
   - 네트워크 에러 시 토큰 삭제 → 서버 재시작 후 동기화 불가능
   - 사용자가 재로그인해야만 오프라인 메모를 동기화할 수 있음

3. **서버 재시작 감지와의 충돌**
   - 서버 재시작 시 토큰 무효화 (방안 1)는 401 에러로 처리됨
   - 네트워크 에러와 401 에러를 구분하면 충돌 없음

---

## 인증 에러(401) vs 네트워크 에러 비교

### 1. 인증 에러(401 Unauthorized)

#### 정의
- **서버는 정상 작동 중**이며 요청을 받았지만, 인증 정보가 유효하지 않아 요청을 거부한 경우
- HTTP 상태 코드: **401**
- 서버가 **응답을 반환함** (에러 응답 포함)

#### 발생 원인

1. **토큰 만료**
   ```
   상황: AccessToken의 만료 시간이 지남
   예시: 토큰 유효기간이 1시간인데, 1시간 1분 후에 API 호출
   ```

2. **토큰 무효화**
   ```
   상황: 서버 재시작으로 인한 토큰 무효화 (방안 1)
   예시: 서버가 재시작되어 DB의 RefreshToken이 무효화됨
   ```

3. **토큰 서명 불일치**
   ```
   상황: JWT 서명 키가 변경됨
   예시: 서버의 JWT_SECRET이 변경되어 기존 토큰 검증 실패
   ```

4. **토큰 형식 오류**
   ```
   상황: 토큰이 손상되었거나 잘못된 형식
   예시: 토큰이 일부만 전송되거나 변조됨
   ```

#### 실제 동작 예시

```javascript
// [프론트엔드] API 호출
fetch('http://localhost:8080/api/v1/users/me', {
  headers: {
    'Authorization': 'Bearer expired_token_here'
  }
})

// [서버] 정상 작동 중
// 1. 요청을 받음 ✅
// 2. JWT 토큰 검증 시도
// 3. 토큰이 만료되었거나 무효함을 확인
// 4. HTTP 401 응답 반환 ✅

// [응답]
{
  "status": 401,
  "ok": false,
  "error": {
    "code": "UNAUTHORIZED",
    "message": "인증이 필요합니다"
  }
}
```

#### 특징
- ✅ 서버가 정상 작동 중
- ✅ HTTP 응답이 반환됨 (상태 코드 401)
- ✅ 응답 본문에 에러 정보 포함
- ❌ 영구적 문제 (토큰 재발급 또는 재로그인 필요)

---

### 2. 네트워크 에러

#### 정의
- 서버에 **연결 자체가 되지 않는** 경우
- HTTP 응답을 받지 못함
- 브라우저/네트워크 레벨에서 발생

#### 발생 원인

1. **서버 종료**
   ```
   상황: Spring Boot 서버가 실행되지 않음
   예시: mvn spring-boot:run을 중지한 상태
   ```

2. **네트워크 연결 끊김**
   ```
   상황: 인터넷 연결이 끊어짐
   예시: Wi-Fi 연결 해제, 케이블 뽑힘
   ```

3. **방화벽/포트 차단**
   ```
   상황: 서버 포트(8080)에 접근 불가
   예시: 방화벽에서 포트 차단
   ```

4. **DNS 해석 실패**
   ```
   상황: 서버 주소를 찾을 수 없음
   예시: localhost를 찾을 수 없음
   ```

#### 실제 동작 예시

```javascript
// [프론트엔드] API 호출
fetch('http://localhost:8080/api/v1/users/me', {
  headers: {
    'Authorization': 'Bearer valid_token_here'
  }
})

// [서버] 종료 상태
// 1. 요청을 받지 못함 ❌
// 2. 연결 자체가 실패
// 3. HTTP 응답 없음 ❌

// [브라우저 에러]
TypeError: Failed to fetch
// 또는
NetworkError: Failed to fetch
```

#### 특징
- ❌ 서버에 연결되지 않음
- ❌ HTTP 응답 없음
- ❌ 브라우저 레벨 에러 발생
- ✅ 일시적 문제 (서버 재시작 또는 네트워크 복구로 해결 가능)

---

### 3. 구체적인 시나리오 비교

#### 시나리오 1: 토큰 만료 (401 에러)

```
[상황]
- 사용자가 로그인한 지 2시간이 지남
- AccessToken 유효기간: 1시간
- 서버는 정상 작동 중

[프론트엔드 동작]
1. API 호출: GET /api/v1/users/me
2. Authorization 헤더에 만료된 토큰 포함

[서버 동작]
1. 요청을 정상적으로 받음 ✅
2. JwtAuthenticationFilter에서 토큰 검증
3. jwtUtil.validateToken() 호출
4. 토큰 만료 확인: isTokenExpired() → true
5. 인증 실패 처리
6. HTTP 401 응답 반환 ✅

[프론트엔드 응답]
{
  "status": 401,
  "ok": false,
  "error": {
    "code": "UNAUTHORIZED",
    "message": "인증이 필요합니다"
  }
}

[결과]
- 서버는 정상 작동 중
- HTTP 응답을 받음
- 토큰 갱신 시도 가능
- 갱신 실패 시 로그아웃 필요
```

---

#### 시나리오 2: 서버 종료 (네트워크 에러)

```
[상황]
- 사용자가 로그인한 상태
- 유효한 토큰 보유
- 서버가 종료됨 (mvn spring-boot:run 중지)

[프론트엔드 동작]
1. API 호출: GET /api/v1/users/me
2. Authorization 헤더에 유효한 토큰 포함

[서버 동작]
1. 요청을 받지 못함 ❌
2. 서버가 실행되지 않음
3. 연결 실패

[프론트엔드 응답]
TypeError: Failed to fetch
// 또는
NetworkError: Failed to fetch

[브라우저 콘솔]
- response.status: undefined (응답 없음)
- response.ok: undefined (응답 없음)
- error.isNetworkError: true

[결과]
- 서버에 연결되지 않음
- HTTP 응답 없음
- 일시적 문제 (서버 재시작으로 해결)
- 토큰은 유효하므로 서버 재시작 후 사용 가능
```

---

#### 시나리오 3: 서버 재시작 후 토큰 무효화 (401 에러)

```
[상황]
- 사용자가 오프라인 상태에서 메모 작성
- 서버가 재시작됨 (방안 1: 토큰 무효화)
- 네트워크 복구 → 자동 동기화 시도

[프론트엔드 동작]
1. API 호출: POST /api/v1/memos
2. Authorization 헤더에 토큰 포함 (무효화됨)

[서버 동작]
1. 요청을 정상적으로 받음 ✅
2. JwtAuthenticationFilter에서 토큰 검증
3. 토큰이 DB에서 무효화되었거나 서명이 불일치
4. 인증 실패 처리
5. HTTP 401 응답 반환 ✅

[프론트엔드 응답]
{
  "status": 401,
  "ok": false,
  "error": {
    "code": "UNAUTHORIZED",
    "message": "인증이 필요합니다"
  }
}

[결과]
- 서버는 정상 작동 중
- HTTP 응답을 받음
- 토큰이 영구적으로 무효화됨
- 재로그인 필요
```

---

### 4. 코드에서의 구분 방법

#### 프론트엔드에서의 구분

```javascript
try {
  const response = await fetch(url, config);
  
  // ✅ 401 에러: 서버가 응답을 반환함
  if (response.status === 401) {
    // 인증 에러 처리
    // 토큰 갱신 시도 또는 로그아웃
  }
  
} catch (error) {
  // ❌ 네트워크 에러: 응답을 받지 못함
  if (error instanceof TypeError || 
      error.message?.includes('Failed to fetch')) {
    // 네트워크 에러 처리
    // 토큰 유지 (일시적 문제)
  }
}
```

#### 차이점 요약

| 항목 | 인증 에러(401) | 네트워크 에러 |
|------|---------------|--------------|
| **서버 상태** | 정상 작동 중 | 종료 또는 연결 불가 |
| **HTTP 응답** | 있음 (401) | 없음 |
| **에러 타입** | `response.status === 401` | `TypeError: Failed to fetch` |
| **문제 성격** | 영구적 (토큰 무효) | 일시적 (서버/네트워크 문제) |
| **해결 방법** | 재로그인 또는 토큰 갱신 | 서버 재시작 또는 네트워크 복구 |
| **토큰 상태** | 무효 (삭제 필요) | 유효 (유지 가능) |

---

### 5. 개선 방안 적용 이유

#### 네트워크 에러 시 토큰 유지 이유

```
[시나리오: 서버 종료 중 네트워크 복구]
1. 사용자가 오프라인 상태에서 메모 작성
2. 네트워크 복구 → 자동 동기화 시도
3. 서버 종료 → 네트워크 에러 발생
4. ✅ 토큰 유지 (일시적 문제)
5. 서버 재시작 후: 토큰이 있으므로 동기화 가능
```

#### 인증 에러(401) 시 로그아웃 이유

```
[시나리오: 서버 재시작 후 토큰 무효화]
1. 사용자가 오프라인 상태에서 메모 작성
2. 서버 재시작 (방안 1: 토큰 무효화)
3. 네트워크 복구 → 자동 동기화 시도
4. 401 에러 발생 (토큰 무효화)
5. ✅ 로그아웃 (영구적 문제, 재로그인 필요)
```

---

## 해결책 비교

### 방안 1: 네트워크 에러 시 토큰 유지 (추천) ⭐

#### 개요
- 네트워크 에러 시: 토큰 유지, 인증 상태만 초기화
- 인증 에러(401) 시: 로그아웃 (토큰 삭제)

#### 장점
1. ✅ 오프라인 메모 동기화 지원
   - 서버 재시작 후에도 토큰이 있으므로 동기화 가능
   - 사용자가 재로그인하지 않아도 자동 동기화 가능

2. ✅ 네트워크 에러는 일시적
   - 서버 종료, 네트워크 끊김은 일시적 문제
   - 토큰 삭제 불필요

3. ✅ 인증 에러는 영구적
   - 401 에러는 토큰이 무효화된 것이므로 로그아웃 처리
   - 서버 재시작 감지(방안 1)와 충돌 없음

4. ✅ 사용자 경험 개선
   - 서버 재시작 후 자동으로 오프라인 메모 동기화 가능
   - 불필요한 재로그인 방지

#### 단점
1. ⚠️ 네트워크 에러와 인증 에러 구분 필요
   - 에러 타입에 따른 분기 처리 필요

2. ⚠️ 인증 상태와 토큰 상태 불일치 가능
   - `isAuthenticated = false`이지만 토큰은 유지
   - UI에서 인증 상태 표시 시 주의 필요

#### 구현 복잡도
- **낮음**: 기존 로직 수정만 필요
- 네트워크 에러 처리 부분만 변경

---

### 방안 2: 현재 로직 유지 (비추천)

#### 개요
- 네트워크 에러 시: 로그아웃 (토큰 삭제)
- 인증 에러(401) 시: 로그아웃 (토큰 삭제)

#### 장점
1. ✅ 구현 간단
   - 현재 로직 그대로 유지

#### 단점
1. ❌ 오프라인 메모 동기화 불가능
   - 서버 재시작 후 토큰이 없어서 동기화 불가능
   - 사용자가 재로그인해야만 동기화 가능

2. ❌ 사용자 경험 저하
   - 불필요한 재로그인 필요
   - 오프라인 메모 동기화 실패

---

### 방안 3: 네트워크 에러 시 재시도 로직 추가 (복잡)

#### 개요
- 네트워크 에러 시: 토큰 유지, 주기적 재시도
- 일정 시간 후에도 실패하면 로그아웃

#### 장점
1. ✅ 오프라인 메모 동기화 지원
2. ✅ 장기간 네트워크 장애 시 자동 로그아웃

#### 단점
1. ❌ 구현 복잡도 높음
   - 재시도 로직, 타임아웃 처리 필요
2. ❌ 불필요한 복잡성
   - 오프라인 메모 동기화는 네트워크 복구 시 자동 재시도됨

---

## 개선 방안

### 최종 추천: 방안 1 (네트워크 에러 시 토큰 유지)

#### 핵심 원칙

1. **네트워크 에러는 일시적 → 토큰 유지**
   - 서버 종료, 네트워크 끊김은 일시적 문제
   - 토큰을 유지하여 서버 재시작 후 동기화 가능

2. **인증 에러(401)는 영구적 → 로그아웃**
   - 토큰이 무효화된 것이므로 로그아웃 처리
   - 서버 재시작 감지(방안 1)와 충돌 없음

3. **오프라인 메모 동기화 지원**
   - 네트워크 에러 시에도 토큰 유지
   - 서버 재시작 후 자동 동기화 가능

#### 수정된 로직

```javascript
async restoreAuthState() {
  try {
    const userProfile = await userService.getProfile();
    if (userProfile) {
      this.setUser(userProfile);
    } else {
      this.logout();
    }
  } catch (error) {
    console.warn('[AuthState] 서버 연결 확인 실패:', error.message);
    
    // 네트워크 에러인지 확인
    const isNetworkError = 
      error.isNetworkError === true ||
      error.message?.includes('Failed to fetch') ||
      error.message?.includes('NetworkError') ||
      error.message?.includes('Network request failed') ||
      error.message?.includes('서버에 연결할 수 없습니다') ||
      (error.name === 'TypeError' && error.message?.includes('fetch')) ||
      (!navigator.onLine);
    
    if (isNetworkError) {
      // ✅ 개선: 네트워크 에러는 일시적이므로 토큰 유지
      // 인증 상태만 초기화 (서버 재시작 후 동기화 가능하도록)
      this.isAuthenticated = false;
      this.user = null;
      // 토큰은 유지 (clearTokens() 호출하지 않음)
      
      // 이벤트 발행 (UI 업데이트용)
      eventBus.publish(AUTH_EVENTS.STATE_CHANGED, {
        user: null,
        isAuthenticated: false,
      });
    } else {
      // 네트워크 에러가 아닌 경우 (예: 401, 403 등)
      if (error.status === 401 || error.statusCode === 401) {
        // ✅ 인증 실패는 영구적이므로 로그아웃
        this.logout({ reason: 'token_invalid' });
      } else {
        // 기타 에러는 인증 상태만 초기화 (토큰은 유지)
        this.isAuthenticated = false;
        this.user = null;
      }
    }
  }
}
```

---

## 구현 계획

### 1. 수정 파일

- `분산2_프로젝트_프론트/js/state/auth-state.js`
  - `restoreAuthState()` 메서드 수정
  - 네트워크 에러 시 토큰 유지 로직 추가

### 2. 수정 내용

#### 변경 전
```javascript
if (isNetworkError) {
  // 서버 연결 불가 시 자동 로그아웃 (네트워크 에러 원인 포함)
  this.logout({ reason: 'network_error' });
}
```

#### 변경 후
```javascript
if (isNetworkError) {
  // 네트워크 에러는 일시적이므로 토큰 유지
  // 인증 상태만 초기화 (서버 재시작 후 동기화 가능하도록)
  this.isAuthenticated = false;
  this.user = null;
  // 토큰은 유지 (clearTokens() 호출하지 않음)
  
  // 이벤트 발행 (UI 업데이트용)
  eventBus.publish(AUTH_EVENTS.STATE_CHANGED, {
    user: null,
    isAuthenticated: false,
  });
}
```

### 3. 테스트 시나리오

#### 시나리오 1: 서버 종료 중 네트워크 복구
1. 사용자가 오프라인 상태에서 메모 작성 (로컬 저장)
2. 네트워크 복구 → 자동 동기화 시도
3. 서버 종료 → 네트워크 에러 발생
4. ✅ 인증 상태만 초기화, 토큰 유지
5. 서버 재시작 후: 토큰이 있으므로 동기화 가능

#### 시나리오 2: 서버 재시작 (토큰 무효화)
1. 사용자가 오프라인 상태에서 메모 작성 (로컬 저장)
2. 서버 재시작 (방안 1: 토큰 무효화)
3. 네트워크 복구 → 자동 동기화 시도
4. 401 에러 발생 (토큰 무효화)
5. ✅ 로그아웃 처리 (정상 동작)

#### 시나리오 3: 일반 네트워크 에러
1. 사용자가 로그인한 상태
2. 네트워크 끊김 → 네트워크 에러 발생
3. ✅ 인증 상태만 초기화, 토큰 유지
4. 네트워크 복구 후: 토큰이 있으므로 자동 인증 복원 가능

### 4. 예상 효과

1. ✅ 오프라인 메모 동기화 지원
   - 서버 재시작 후에도 토큰이 있으므로 동기화 가능
   - 사용자가 재로그인하지 않아도 자동 동기화 가능

2. ✅ 사용자 경험 개선
   - 불필요한 재로그인 방지
   - 서버 재시작 후 자동으로 오프라인 메모 동기화

3. ✅ 서버 재시작 감지와 충돌 없음
   - 서버 재시작 시 토큰 무효화는 401 에러로 처리
   - 네트워크 에러와 구분되어 정상 동작

---

## 관련 문서

- [오프라인 메모 동기화 설계](../fault-tolerance/OFFLINE_MEMO_SYNC.md)
- [로그인 성능 최적화](./LOGIN_PERFORMANCE_OPTIMIZATION.md)

---

## 다음 단계

1. ✅ 문서 작성 완료
2. ✅ 사용자 허락 완료
3. ✅ 코드 수정 완료 (`auth-state.js`)
4. ⏳ 테스트 시나리오 검증

---

## 구현 완료 내역

### 수정된 파일

- `분산2_프로젝트_프론트/js/state/auth-state.js`
  - `restoreAuthState()` 메서드 수정
  - 네트워크 에러 시 토큰 유지 로직 적용

### 주요 변경 사항

1. **네트워크 에러 처리 개선**
   - 네트워크 에러 시 `logout()` 대신 인증 상태만 초기화
   - 토큰은 유지하여 서버 재시작 후 동기화 가능

2. **인증 에러(401) 처리 유지**
   - 401 에러 시 기존대로 `logout()` 호출
   - 토큰 무효화는 영구적 문제이므로 로그아웃 처리

3. **이벤트 발행 추가**
   - 네트워크 에러 시 `AUTH_EVENTS.STATE_CHANGED` 이벤트 발행
   - UI 업데이트를 위한 이벤트 처리

